---
layout: post
title: "Making a F*cking Interpreter - Day Three"
date: 2019-10-09 11:43:00 +0200
categories: dev project cpp
---

*You can find the code for this project (and the result as well) on [AugustoQueiroz/fucking-interpreter](https://github.com/AugustoQueiroz/fucking-interpreter)*

So, the story so far: The interpreter is working, and has an interpreter interface (the pretty way you can enter code iteratively like when you launch `$ python`. The interpreter was already capable of fully interpretting the BrainF\*ck language (I mean, it's a pretty simple language). The main thing that was missing for the base functioning of the interpreter was the capability of taking a file as input and interpreting the contents of that file (like you do when you `$ python yourfile.py`). The next important steps for finishing this interpreter are to make a pre-validation of the programs before they are interpreted, to make sure they are well formed. As of now, the interpreter will accept any ascii string, skipping any unknown characters as though they were comments. This, in itself, is not a horrible behavior, as it can be acceptable. However, it will also not complain of open-ended loops (a file containing a `[` but no matching `]`), which while not capable of causing problems are still wrong syntax for the language, and it will accept the closing of unopened loops (`]` without matching `[`). This is the real big problem, as it will try to end a loop that was never started, and thus can end up sending the pc to any position.

Now, with the two main goals for today (taking a file as input and validating a program before running it), let's get started.

## Day Three

As yesterday, first things first, and by first things I mean easiest things first. Taking a file as input. To do that I'm taking the arguments passed through the command line. This can easily be done by adding `int argc, char* argv[]` as arguments of the `main` function. The `argc` argument stands for "argument count" and it tells us how many arguments have been passed through the command line. This will always be greater than or equals to one, since the name of the program itself is an argument (the "./yourprogramname"). The `argv` parameter stands for "argument values" (I'm totally making this up, but great chance I'm right, and it's like this that I think of it) and it is an array of strings that are the space-separated arguments of your program. So, if you call it like `$ ./myprogram and my arguments`, `argv = ["./myprogram", "and", "my", "arguments"]`.

Anyways, with that I can use argc to know whether to lauch the interpreter interface (if the *argument count* is equals to 1), or if the user is trying to pass a file. In the second case, I know the file name will be the second argument received, `argv[1]`. This way, if a file name is given I'll try to open it and, if successfull, I can read it's contents and pass it as a program to the interpreter, and then have it run over it. This is also where you'd do any name vetting for the program (say you only want to accept programs with extension ".bf", or want names to be formatted a certain way).

### Validating Input

Easy part done, now moving on to the... well, still easy part of validating the program, going through it to make sure that no horrible flaws are encountered. Because we're dealing with a doubly infinite line, and BrainF\*ck *is* an extremely simple language, this is just down to the problems above: cannot have an open loop, cannot close an unopened loop, and that's it. You can move anytime you like, and you can increment and decrement anywhere you want. Because this commands are single-character they can't be malformed. To make this verification I'll create a new function inside the `Interpreter` class that validates a string as valid BrainF\*ck code. When a program is passed as a file, it will test the entire program before accepting it. When in the interpreter interface, it will check each input as a self-contained program, even though it will make part of the program as a whole. This brings some draw-backs (without that you are able to start a loop in one input and end it in another, which now will become impossible), but it's also more organized and helps to prevent errors due to bad practice. Although I might later add a command or mode in which starting a loop in a command and ending it in another might be a good idea).

Since I'm going to be validating the code anyways, I might as well make the loops more optimized, performance-wise. I'll save the loop pairings so that not only going back to the start of the loop will happen instantly, but skipping the loop as a whole will do so too. In this case I wen't with saving the loop pairings in a map, this way going from the end to the start is instantaneous, while going from the start to the end is linked to the total number of loops rather than the total number of operators. The total number of loops will always be *at least* half the total number of operators, so while this doesn't improve the asymptotic performance of the skip function, it is, still, an improvement. A further improvement can be achieved by adding a second map, which index the endings of the loops by their beginnings, allowing for instantaneous skipping of a loop.

### Some notes on implementation

I didn't create, for now, an error class. This means that, for now, the errors are only represented by an error code, which doesn't allow for better, more interesting, error codes, such as saying where the error is in the file. This can be solved two ways: one is to simply print out the error message in the moment the error is detected, when it is known where the error is, and keep on just returning the error code. Another is to create an error class, which contains more information about the error than just it's code. It seems to me at first look that the latter is a better, more eleguant and versatile solution, but at the same time I can't quite see use cases where the former would fail. It is certainly less modular, and gives too much responsibilty to the preInterpretation function, but a responsibility that isn't completely out of it's scope.

## Post-Mortem

I've achieved something that I already think is somewhat interesting, however simple this project was. It got me back in touch with C++, and allowed me to revisit somethings that I hadn't used in a while. Also, documenting it for the blog was interesting, and I think a good start to populating the blog and getting me invested in it. But now, although I intend to continue improving on this interpreter, it will probably be more on a "feel like it" basis, as I take other projects that are more complex and more interesting.
